---
permalink: /self-assessment.html
layout: default
---



<style type="text/css" media="screen">
  .container {
    margin: 10px auto;
    max-width: 800px;    
  }
  h1 {
    margin: 30px 0;
    font-size: 2em;
    color: #2B547E;
    line-height: 1;
    letter-spacing: -1px;
    text-align: center;
  }
  h2 {
    margin: 30px 0;
    font-size: 1.5em;
    color: #2B547E;
    line-height: 1;
    letter-spacing: -1px;
    font-style: italic;
    text-align: center;
  }
  .button {
    background-color: #2B547E;
    border: none;
    color: white;
    padding: 20px 20px;
    text-align: center;
    text-decoration:none;
    display: inline-block;
    font-size: 20px;
    margin: 5px auto;
    cursor: pointer;
    white-space: normal;
    border-radius: 8px;
  }

  figure {
    display: inline-block;
    border: 1px dotted gray;
    margin: 8px;
  }

  figure img {
    vertical-align: top;
    width: 600px;
    height: auto;
  }

  figure figcaption {
    border: 1px dotted blue;
    text-align: center;
    font-style: italic;
    color: #2B5472
  }

 </style>

<div class="container">
<h1>Professional Self-Assessment</h1>
<p>My path through the Computer Science program began in January 2018. My passion for computer programming drove me to fill in the gaps in my previous knowledge and helped to strengthen my 
  skills all the more. My passion for computer programming began several years ago, using languages such as Basic, Pascal, and C++ to build simple programs to test out how things worked.
   Since then, Iâ€™ve utilized my skills in programming to help locate solutions to work related issues through the means of software development, generating applications to be used to help 
   streamline processes and build permanent solutions that are utilized to this day in my company. The path to my degree has been stemmed mainly due to my wish to truly devote myself to 
   software development, taking challenges found with nothing more than the problem and requirements, and help to develop solutions that can help resolve more issues.
</p>
<p>
  My time in the Computer Science program have aided me in expanding my knowledge not in various skillsets, from learning new programming languages, to developing better critical thinking
   skills and putting new methodologies of development at my disposal. In the short time during my learning in the Computer Science program, my time has been spent increasing my knowledge
    not only of new programming languages, such as Java and Python, as well as new skillsets, such as building SQL and NoSQL databases, but also to utilize all these skills as a whole to
     develop complete projects, finding solutions to challenges and better set to face each incoming challenge with the same mindset and purpose.
  </p>
<h2>Collaborating in a Team Environment</h2>
<p>Throughout this program, the knowledge that development is more than just one person coding has been a thought that has helped in identifying means of working better within a team
 environment. Utilization of code hosting platforms such as GitHub has helped to work with a team by having a single place where all work can be stored, allowing for review of the changes 
 being made, identify conflicts, and work through with the team to determine the best course of action. Below is an example showing not only the handling of branches within a team repository
 , but also showing a review of code, adding in detail to better explain what has been located and any changes that would need to be made. </p>
<p>
In addition to this, utilization of comments and proper naming schemes are helpful in assisting those having to modify and upgrade the source code by not only outlining the main objective
 of a given set of code, but to do so on a line-by-line basis, explaining the intention and expected results. In so doing, the source code is much easier to not only understand, but to
  traverse, and identify where adjustments and updates will be needed. 
</p>
<p>
During my tenure in the Computer Science program, I was able to employ strategies for building collaborative environments that enable diverse audiences to support organizational decision
 making in the field of computer science by utilizing these very tools. With GitHub, I was able to ensure that my work was properly aligned in individual branches (Example 1) and was properly
  reviewed by others prior to pushing into the main branch to ensure that the code was not only properly vetted (Example 2), but also that there were no conflicts within it. This was helped by means of proper
   comments and naming schemes to ensure that the source code was simple to follow for those reviewing, making for a more streamlined approach.
</p>
<p>
<figure>
  <img src="/docs/assets/images/github_img.png" alt="GitHub Branches" class="center">
  <figcaption>Example 1: CS-310: Collaboration and Team Project - Utilizing Github to build branches to main branch for proper review prior to consolidation</figcaption>
</figure>
<br>
<figure>
  <img src="/docs/assets/images/github_img2.png" alt="GitHub Code Review" class="center">
  <figcaption>Example 2: CS-310: Collaboration and Team Project - Reviewing code submitted via Github for accuracy prior to merging with main branch</figcaption>
</figure>
</p>
<h2>Communicating to Stakeholders</h2>
<p>
Not only having to ensure that your team is kept apprised of your work, the stakeholders, be them an outside client to a group of internal customers, their understanding and feedback to the
 progress on a project is vital to ensure not only the end results are met, but they are met to fit all the needs outlined within requirements. First and foremost, communication must be done 
 at the outset, to first gather their vision of the end result, and from there be able to obtain the necessary requirements to even begin the development. From these, the next logical steps 
 would be development of outlines and tools in which to better comprehend and map out the application, such as pseudocode or a workflow.  It is from these basic parts that begin the 
 documentation process, better to flesh out and give more depth to the skeleton built with the initial steps. With a mutual approach between all parties on how the project will develop, 
 this not only allows the team to better understand the end result, including those who will develop as well as test, but allows the stakeholders to better know what the end result will be 
 for their own means, allowing them to better approach their own acceptance testing.
</p>
<p>
During my time in the Computer Science program, I was able to design, develop, and deliver professional-quality oral, written, and visual communications that are coherent, technically sound,
 and appropriately adapted to specific audiences and contexts. This was done by using a combination of all the above referenced methodologies, from developing simple pseudocode to better
  outline the basic flow of the program (Example 3), which in turn could be turned into proper workflow charts to help determine how each individual step will work (Example 4), including how
   possible variations may branch out from a one task to another. Additionally, by use of object-oriented design, I could easily map out individual classes into use cases (Example 5), which can be properly
    viewed within a sequence diagram (Example 6). With these tools, the ability to share the plans and status of the project with all stakeholders in the project, ensuring that all known information was
    shared with the team as a whole.
</p>
<p>
<figure>
  <img src="/docs/assets/images/pseudo_img.jpg" alt="Monitoring System PseudoCode" class="center">
  <figcaption>Example 3: IT-145: Found in App Development - Pseudocode to map out logical flow of Monitoring System</figcaption>
</figure>
<br>
<figure>
  <img src="/docs/assets/images/flow_img.jpg" alt="Flowchart of Thermostat" class="center">
  <figcaption>Example 4: CS-350: Emerging System Architecture & Technology  - Workflow Chart of Thermostat to trigger LEDs based on sensor and temperature settings</figcaption>
</figure>
<br>
<figure>
  <img src="/docs/assets/images/crc_img.jpg" alt="Use Case" class="center">
  <figcaption>Example 5: IT-315: Object Oriented Analysis & Design - Use Case for User Class for a Student Enrollment Application</figcaption>
</figure>
<br>
<figure>
  <img src="/docs/assets/images/sis_img.png" alt="Sequence Diagram" class="center">
  <figcaption>Example 6: IT-315: Object Oriented Analysis & Design - Sequence Diagram for Student Enrollment Application</figcaption>
</figure>
</p>
<h2>Data Structures and Algorithms</h2>
<p>
In any manner of development, one is only able to build up properly based on a solid structure, and from there the application can be properly fleshed out as long as it can be built upon said
 structure. By building up in a modular fashion, not only does this allow for simpler development and testing by ensuring things are built piece by piece, but also allows for ease of usage not
  just in multiple instances of an application, but in multiple applications as it can be plugged in as seen fit. Usage of variations of data types and structures, such as structs in C/C++ and 
  classes in Java allow for  multiple data elements to be accessible without needing to build more complicated programs. Lastly, the use of algorithms helps to find means of traversing data in
   a more organized and simpler manner, leading to reducing computing time for execution, leading to quicker results for the end user.
</p>
<p>
Using these methods, I was able to design and evaluate computing solutions that solve a given problem using algorithmic principles and computer science practices and standards appropriate to 
its solution, while managing the trade-offs involved in design choices. This was done via a modular approach, by building up individual structures (Example 7) and classes (Example 8) that could
 better be used for the purpose of a singular task, such as creating an object to be created, edited, and removed as needed. The building of algorithms, such as vector sorting (Example 9) and
  hash tables (Example 10), helped to build up the data structures into proper formats for ease of adding, removing and seeking data as needed for the execution of the application. These
   methods combined not only ensure a solution that can meet all requirements, but also ensures no trade-off in the design choice by ensuring that efficiency is ever a forefront thought.
</p>
<p>
<figure>
  <img src="/docs/assets/images/struct_img.jpg" alt="C++ Struct for BidInfo" class="center">
  <figcaption>Example 7: CS-260: Data Structures and Algorithms - C++ Struct BidInfo to hold data elements regarding bids passed</figcaption>
</figure>
<br>
<figure>
  <img src="/docs/assets/images/java_class_img.jpg" alt="Java Class for Appointment" class="center">
  <figcaption>Example 8: IT-415: Found in App Development - Java Class Appointment to hold data elements regarding appointments requested by user</figcaption>
</figure>
<br>
<figure>
  <img src="/docs/assets/images/vector_sort_img.jpg" alt="Vector Sort Algorithm" class="center">
  <figcaption>Example 9: CS-260: Data Structures and Algorithms - C++ Vector Sorting algorithm to sort through data elements found in vector into low and high groups</figcaption>
</figure>
<br>
<figure>
  <img src="/docs/assets/images/hashtable_img.jpg" alt="Hash Table" class="center">
  <figcaption>Example 10: CS-260: Data Structures and Algorithms - C++ Hash Table to search table for hash key until either a match is found or null returned</figcaption>
</figure>
</p>
<h2>Software Engineering and Databases</h2>
<p>
 In any means of development, a developer can only be as good as the tools they have at their disposal to reach their solution. In software development, this remains true in that without
 particular tools that can be utilized, a program can only do so much. With tools that help to better visualize solutions and the application as a whole, such as graphical user interfaces, 
 to how data can be properly stored not just for use during program execution, but for long term storage as well, such as databases and file storage, the use of these tools help to add depth
  to any development project, allowing for more functionality for the end user for more prolonged and ease of use.
</p>
<p>
In these ways, I have demonstrated an ability to use well-founded and innovative techniques, skills, and tools in computing practices for the purpose of implementing computer solutions that
 deliver value and accomplish industry-specific goals. By being able to create a graphical user interface that is more intuitive to the end user (Example 11), thereby allowing them an easier
  front end to be able to access and utilize the application leads to allowing a wider audience to be able to make use of it. Adding in databases such as SQL (Example 12) and NoSQL (Example 13)
   database, as well as utilizing pulling and storing data in text-based files helps to allow data to be stored properly, ensuring user data is permanently accessible for as long as the user
    has need of it, helps to push for a more long-term solution.
</p>
<p>
<figure>
  <img src="docs/assets/images/gui_img.jpg" alt="Graphical User Interface" class="center">
  <figcaption>Example 11: CS-250: Software Development Lifecycle - Java Form to generate Graphical User Interface</figcaption>
</figure>
<br>
<figure>
  <img src="docs/assets/images/sql_img2.png" alt="SQL Query" class="center">
  <figcaption>Example 12: CS-330: Introduction to SQL - SQL query to return all data from table flight</figcaption>
</figure>
<br>
<figure>
  <img src="docs/assets/images/mongodb_img.jpg" alt="MongoDB Collection" class="center">
  <figcaption>Example 13: CS-499: Computer Science Capstone - MongoDB Collection contact in taskScheduler database</figcaption>
</figure>
</p>
<h2>Security</h2>
<p>Along with reaching the desired solution, the ability to keep said application both stable and secure holds a great deal of merit. When considering the stability of an application, it cannot 
  be easily broken or manipulated to do beyond its desired scope. In terms of security, the fear of personal data being accessible to anyone will always be a concern that need to be approached 
  with the utmost care. By adopting a DevSecOps methodology of software development, keeping security as much a part of the development process as any other aspect ensures that security is
   never just an afterthought, but a main aspect of the process.
</p>
<p> It is in these ways that I have developed a security mindset that anticipates adversarial exploits in software architecture and designs to expose potential vulnerabilities, mitigate design 
  flaws, and ensure privacy and enhanced security of data and resources. By considering that security needs be considered during the development process, taking measure of the requirements
   helps to determine possible vulnerabilities. Such in the case of allowing user input to be made, issues such as SQL injection (Example 14) and buffer overflow could be a concern. However, by
    ensuring the data input is properly validated and only allowed to the extent as per requirements (Example 15), this helps reduce these types of issues. Even at times there can be unforeseen
     circumstances, but the code must go on and the application must not break. By adding in exception catches and error handling, these unforeseen issues, be them due to outside interference
      or an error yet to be discovered, the error will be captured and handled by letting the user know, but still will not cause the application to break, which in turn ensures that it runs 
      as needed, but also secures the source code from those who should not have this access. Lastly, the best method of not just ensuring that code functions as required, but that limits and 
      validations are placed is via testing (Example 16). By building tests for the code, you can seek out the limitations, finding when things will not just pass when intended, but fail when
       they should as well, better ensuring that all expectations are met not just logically as per the code, but by example and execution as well (Example 17).
  </p>
  <p>
  <figure>
    <img src="docs/assets/images/sql-inject-img.png" alt="SQL Injection" class="center">
    <figcaption>Example 14: CS-405: Secure Coding - SQL Injection test to catch attempts and ensure they are handled properly</figcaption>
  </figure>
  <figure>
    <img src="docs/assets/images/data_validation_img.jpg" alt="Data Validation" class="center">
    <figcaption>Example 15: CS-199: Computer Science Capstone - Java Form function added to text fields to ensure character length is kept within acceptable limits</figcaption>
  </figure>
  <figure>
    <img src="/docs/assets/images/unit_test_img.jpg" alt="Unit Testing" class="center">
    <figcaption>Example 16: CS-405: Secure Coding - Unit Testing code developed to test various functionality of applications</figcaption>
  </figure>
  <figure>
    <img src="/docs/assets/images/test_img.png" alt="Unit Testing Execution" class="center">
    <figcaption>Example 17: CS-405: Secure Coding - Unit Test execution to validate if testing items pass or fail execution</figcaption>
  </figure>
  </p>
<h2>Portfolio Artifact 1 - Task Scheduler</h2>
<p>
  The first artifact added to this portfolio is a Task Scheduler, which holds Contact, Appointment and Task information. The application was written in Java, and during consideration for 
  enhancement, it was determined to keep the programming language used the same for this artifact. The reason for the selection to the ePortfolio is that the application was originally used 
  for testing purposes only, without any true application base developed. With the basic structure already built, it was a perfect example to not only complete to make it functional, but to 
  make the enhancements to make it function in a more user-friendly manner. By adding a graphical user interface generated by Java forms, this helps to expand the audience of the application 
  wider as the user-friendly design will make it more appealing to more. By taking the already existing data structures created for the contact, appointment, and task elements, and putting 
  into use the CRUD functionality, this will help show the ability to reuse assets for expanded functionality. Lastly, by implementing a MongoDB database that will hold the data, this helps 
  to increases the usability of the application, allowing for long term storage of information, but also to allow for easier access to the existing data elements via the MongoDB query 
  functionality to insert, read, edit, and delete user information. 
</p>
<h2>Portfolio Artifact 2 - Monitoring System</h2>
<p>
  The second artifact selected is a Monitoring System written in Java. The original application was built solely to pull data from a text-based file and display the information to the terminal. 
  The reason for inclusion of this application is that the structure of the application was perfect for an upgrade due to the limited functionality that was considered. First off it requires
   outside data to function, which was original a text-based file.  The update was made to utilize a CSV file which does not alter its text-based functionality but allows for easier reading
    and writing to the files due to the delimiter. With data being read from the text file, the next step was to ensure that alterations to the data could be made, such as adding additional 
    records, or even updating existing information, to allow more versatility to its purpose. Additionally, the addition of utilizing an algorithm, in this case a binary search tree, made the 
    most sense to cut down on search times through large volumes of data, to have better return time. Taking steps further, the use of the algorithm which for most would be helpful using it
     with number-based values (such as a system generated unique identifier), taking the steps to push the algorithm to build up based on strings helps to better show an understanding at the
      versatility that these algorithms can have with the data elements utilized, making it so even text-based data can be used for ease of searching.
</p>
<br>
<p>
  Further details regarding the enhancement of the selected artifacts can be found in the artifact sections below. 
</p>
<p class="container">
<a href="/index.html" class=button>Home</a>
<a href="/code-review.html" class=button>Code Review</a>
<br>
<a href="/task-scheduler.html" class=button>Artifact 1 - Task Scheduler</a>
<a href="/monitoring-system.html" class=button>Artifact 2 - Monitoring System</a>
</p>
</div>